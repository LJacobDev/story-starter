# Copilot Working Memory Reference

## Current Project State
- **Last Known Good State**: All unit tests passing. StoryDetails edit and delete implemented with confirmation; App.vue demo fallback fixed; Home grid and filters stable.
- **Currently Working**: Phase 3.2.1g — Tests-first: Share link behavior (navigator.share with clipboard fallback, private-story warning).
- **Last Test Results**: 100% pass locally. Delete spec passes after stubbing Home on redirect to avoid unintended data fetching.
- **Known Issues**:
  - Real toasts not yet integrated (placeholders only); plan to add shadcn toast after 3.2.1l.
  - Image pipeline (upload/URL) and A11y polish for StoryDetails pending (3.2.1i–l).
  - Preview modal remains deferred (3.2.2 optional).

## Key File Relationships
- `src/views/StoryDetails.vue` uses: `useStory.getById`, `useStory.update`, `useStory.remove`, `vue-router` (watches `route.params.id`), and `useAuth` for `isOwner` (compares `user.id` to `story.user_id`).
- `src/composables/useStory.ts` depends on: `utils/supabase` client; table `story_starter_stories` with RLS.
- `src/views/Home.vue` uses: `useStories.fetchPublic/fetchMine`. Note: when tests navigate Home, these calls can run; unit tests that redirect to Home should stub the view to avoid external fetches.
- `src/App.vue` includes a no-router fallback handling `/demo` for unit tests.

## Recent Changes Made
- [2025-09-18]: StoryDetails — Added owner-only Edit with form (title, story_type, genre, description, image_url, is_private, content), validation caps (title ≤120, genre ≤60), Cancel/Save with pending; wired to `useStory.update`.
- [2025-09-18]: StoryDetails — Added Delete with confirm dialog and pending; on confirm calls `useStory.remove` then navigates to Home.
- [2025-09-18]: Tests — Added `tests/unit/StoryDetails.edit.spec.ts` and `tests/unit/StoryDetails.delete.spec.ts`; delete spec stubs Home to prevent Supabase fetch side-effects; both suites passing.
- [2025-09-18]: Composables — Implemented `useStory.update(id, patch)` and `useStory.remove(id)` with error mapping.
- [2025-09-18]: App — Updated no-router fallback in `App.vue` to handle `/demo`, restoring passing demo/logo test.

## Next Steps Plan
1. 3.2.1g — Write `tests/unit/StoryDetails.share.spec.ts` for Share behavior (navigator.share, clipboard fallback, private warning).
2. 3.2.1h — Implement Share button/logic with graceful fallback; keep temporary console/toast placeholders.
3. 3.2.1i/j — Image handling tests then implementation (URL validation and upload flow).
4. 3.2.1k/l — A11y tests then polish (focus, labels, Esc closes confirm; axe clean).
5. After 3.2.1l — Integrate shadcn toast system and replace placeholders.

## Verification Plan
- Automated: `vitest` unit suites for StoryDetails edit/delete continue to pass; add new Share tests and run.
- Manual checks:
  - Open a story you own → Edit, Save persists; Cancel restores.
  - Delete → confirm dialog → on confirm, story removed and redirected Home without console errors.
  - Share (after implementation): navigator.share when available; otherwise URL copied to clipboard; private-story warning shown.

## Rollback Plan
- If regressions: revert `StoryDetails.vue` changes and corresponding `useStory` methods; re-run tests.
- If Share introduces instability: feature-guard Share UI and keep tests skipped until fixed.

## Human-parsable summary
- StoryDetails now supports Edit (with validation and pending states) and Delete (confirm + redirect). Supporting APIs `update` and `remove` live in `useStory`.
- Navigation to Home during unit tests can trigger data fetching; tests that validate post-delete navigation stub Home to avoid side-effects.
- Next up: add Share tests, then implement Share with clipboard fallback and private warning; defer real toasts until end of 3.2.1.

Update timestamp: 2025-09-19.



## Context Section about Phase 4 Planning (Generated by another model in ask mode — agents, don’t directly edit this section but be aware of it)

Purpose
- Deliver LLM-based story generation via a minimal Supabase Edge Function proxy (“gemini-proxy”) that only sanitizes inputs/outputs and enforces basic limits/rate‑limits. All prompt engineering and output parsing happen on the frontend.
- Phase 4 is the MVP for generation; Phase 6 adds advanced controls (seed lock, custom types, richer undo, metadata persistence).

User journey
- User clicks “Generate New Story.”
- A form collects structured prompts:
  - Story type: short-story | movie-summary | tv-commercial. Internally stored as hyphen‑slugs; UI displays labels with spaces (“Short story,” “Movie summary,” “TV commercial”).
  - Optional title, genre, tone, creativity.
  - Dynamic tags: themes, plot points.
  - Dynamic characters: name, role (protagonist/antagonist/ally/other), optional description.
  - Free‑text “additional instructions” (warn if > 800 chars; allow up to 2000).
  - Optional image (upload to Supabase Storage or paste URL).
  - Privacy toggle (default private; user can opt‑in to public).
- Submit:
  - Frontend constructs the full model prompt string (prompt engineering lives entirely in the client).
  - Frontend instructs Gemini to return strict JSON (via prompt content).
  - Frontend POSTs that final prompt string to the gemini‑proxy Edge Function.
- Edge Function behavior:
  - Validates request size and rate limits.
  - Sanitizes the incoming prompt (trim/collapse whitespace, strip obvious HTML/scripts/control characters).
  - Forwards the sanitized prompt to Gemini as‑is (no server-side templating or schema instructions).
  - Receives Gemini text, sanitizes it (remove BOM, dangerous tags, normalize whitespace; optionally pass through code‑fences untouched).
  - Returns sanitized text to the frontend without parsing or reformatting.
- Frontend then:
  - Cleans fences/backticks if needed, extracts JSON, validates against the client schema, and shows a preview.
  - From preview: Save (persist), Retry (fresh sample) with Undo to restore previous preview, Edit prompts (return to form), or Discard (no persistence).
  - Drafts remain in memory only until Save (no “draft” rows in DB for Phase 4).

Data conventions and limits
- Story types: hyphen slugs in DB/APIs; space‑separated labels in UI.
- Images:
  - Allowed types: png, jpeg, webp.
  - Max size: 2 MB.
  - Dimensions: min 200×200, max 4000×4000; any aspect ratio.
  - Stored in bucket story-covers with owner‑only RLS; display via signed URLs.
  - If none, show type‑specific monochrome SVG fallback (decorative, aria‑hidden):
    - Short story → open book (slate/gray).
    - Movie summary → filmstrip (indigo/blue).
    - TV commercial → clapperboard or megaphone (emerald/green).
- Input validation (client) and guidance:
  - Title ≤ 120; Genre ≤ 60; Tone ≤ 60.
  - Themes ≤ 10, each ≤ 30.
  - Plot points ≤ 10, each ≤ 200.
  - Characters ≤ 6; name ≤ 60; description ≤ 400; role is enum.
  - Additional instructions ≤ 2000; warn when > 800 (latency hint).
- Server safeguards (edge):
  - Enforce reasonable total input budget (~6000 chars) and moderate rate limits.
  - Return sanitized model text; do not attempt JSON parsing.

Privacy and access control
- Default is_private = true on the form; Save preserves user choice.
- RLS: anon can read public; authenticated can read public + own; writes are owner‑only with WITH CHECK.

Retry/Undo semantics
- Retry always requests a fresh sample (no deterministic seed in Phase 4).
- When a retry completes, the preview is replaced; Undo restores the prior preview (single‑level undo).
- Phase 6 will add a visible “Lock seed” toggle for deterministic generations, and deeper undo for text fields.

Responsibilities split
- Frontend:
  - Prompt builder: composes final model prompt, includes strict “respond only with JSON” instructions and the JSON schema description.
  - Calls gemini‑proxy with the prompt string.
  - Extracts and parses JSON from the sanitized text; validates schema; handles user‑visible errors.
  - Image validation/upload, preview, save flow, idempotency on Save, toasts.
- Edge function:
  - Safety and hygiene only: input/output sanitization, size caps, moderate per‑user rate limits (e.g., default: ~8/min, 60/hour, 200/day — adjustable via env).
  - Transparent pass‑through to Gemini; no server‑side templating or response shaping beyond sanitization.
  - Clear error taxonomy: 400 validation, 429 rate limit with Retry‑After, 5xx transient.

Out of scope for Phase 4 (defer to Phase 6+)
- Custom story types authored by users.
- Persisting generation request metadata (prompts/settings) in DB.
- Deterministic seed controls (add visible “Lock seed” toggle later).
- Multi‑level undo for form editors.
- AI image generation.

Quality gates for Phase 4
- TDD for form behavior, prompt builder, client parsing, preview/save/undo, image pipeline, and edge function contract (sanitization + rate limit).
- Manual checklist includes privacy default, length caps/warnings, upload constraints, retry→undo, 429 handling UX, and basic a11y.

Key risks and mitigations
- Non‑JSON model replies → robust client extraction and schema validation; friendly parse errors.
- Latency → input caps and 800‑char warning; visible progress; no server templating to keep flow simple.
- Duplicate saves → client idempotency key; disable Save while pending.
- Storage misuse → client/type/size/dimension checks + bucket RLS; signed URLs only.

Here’s the append-only update block for the Phase 4 section.

## Phase 4 Addendum — New Decisions and Execution Details (since last update)

- Model default: gemini-2.5-flash.
- Edge function request shape confirmed: POST { prompt: string } only; proxy sanitizes input/output and forwards as-is; frontend owns prompt engineering and JSON parsing.
- Rate-limit/env knobs finalized: RL_BURST, RL_PER_HOUR, RL_PER_DAY, MAX_PROMPT_CHARS (~6000). Moderate defaults; adjustable via env.
- Storage confirmed: bucket story-covers; path userId/storyId/filename; owner-only RLS; signed-URL viewing.
- Test strategy (TDD) options:
  - Option A (parallel-safe): place Phase 4 specs under tests/phase4 and gate them so CI/Phase 3 aren’t affected. Local run:
    ````bash
    RUN_PHASE4=1 vitest --include "tests/phase4/**/*.spec.ts" --watch
    ````
    Gate each spec:
    ````ts
    const RUN_PHASE4 = process.env.RUN_PHASE4 === '1';
    (RUN_PHASE4 ? describe : describe.skip)('Phase 4 — <suite>', () => { /* … */ });
    ````
  - Option B (single-stream): when Phase 3 wraps or if the same agent continues, place tests in the normal locations immediately (tests/unit, tests/integration, tests/edge) without gating.
- Branching to avoid collisions with Phase 3: work on a phase4-prep branch; separate VS Code window optional. Do not touch:
  - src/components/stories/*, src/views/Home.vue, src/composables/useStories.ts, or existing Phase 3 tests.
- Safe, additive deliverables to start now (unreferenced by Phase 3):
  - docs/phase4/: gemini-proxy contract + runbook, image pipeline guide, prompt-builder notes, a11y/UX checklist.
  - supabase/functions/gemini-proxy/: sanitize-and-forward scaffold with env-driven limits (not wired to UI).
  - src/utils/: extractJson, slugify/humanize story type, imageValidation, idempotencyKey (+ gated tests).
  - src/types/generation.ts; src/composables/useGeneration.ts (stub; not imported yet).
- Execution note: test gating is optional. If the current Phase 3 agent proceeds to Phase 4 next, use Option B and place tests in the standard folders.


## Phase 4 Addendum — Optional “Revise with AI” for Existing Stories (post‑Phase‑4)

Summary
- Feature: add a “Revise with AI” action available on any story the current user owns.
- Flow:
  1. Owner clicks “Revise with AI”.
  2. Modal shows the existing story text (read‑only) and a free‑text instructions box where the user writes revision goals (≤ 2000 chars; warn if > 800).
  3. Frontend composes the prompt (story text + user instructions) and POSTs { prompt: string } to gemini‑proxy.
  4. gemini‑proxy sanitizes and forwards; frontend receives sanitized text, extracts JSON or content, validates it, and shows a preview of the revised text.
  5. User chooses: Save as New Story OR Overwrite Existing Story. If overwrite, show confirmation (irreversible) and require an explicit confirm.
  6. Save uses owner RLS; idempotency key prevents double writes. If overwriting, preserve user_id and ensure update policy WITH CHECK prevents ownership changes.
- Implementation timing: deferred until Phase 4 core generation/save/preview/image flows are complete.

Important implementation/UX considerations
- Prompt limits & token budget: raw story text can be large. Enforce client truncation or summarize long stories before sending; warn user about cost/latency when large.
- Response shape: decide expected response (full JSON with title/description/content/image_url or plain revised content). Document schema the frontend will validate.
- Overwrite safety: require explicit confirmation and surface a clear rollback plan (encourage “Save as New” by default). Consider auto‑creating a backup copy before overwrite (Phase 6 enhancement).
- Permissions: only story owners may use this; enforce via UI and server RLS.
- Rate limits & quotas: revisions count against generation quota; ensure gemini‑proxy rate limits and UX reflect 429/retry guidance.
- Idempotency & dedupe: include idempotencyKey to avoid duplicate saves when users retry.
- Metadata & audit: kept out of Phase 4 per earlier decision. If you want traceability later, plan to add generation metadata storage in Phase 6.
- Images: if the revised output may include image_url, decide whether to accept and persist it; validate URL or offer upload instead.
- Undo/history: Phase 4 offers single confirmation. Phase 6 can add multi‑version history and multi‑level undo.
- Edge function budget: consider a slightly higher MAX_PROMPT_CHARS for revision flows or add a summarization step to reduce prompt size.

Questions to clarify (for inclusion in the plan)
- Default save behavior: prefer “Save as New” by default, or present both options equally?
- Expected response schema for revisions (full JSON with metadata, or just content string)?
- Will we allow the revision to change story_type/genre/title, or only content?
- Should overwrites automatically update the existing story_count/profile triggers, or should we treat overwrites as distinct for analytics?
- Any special rules for images in revised responses (auto‑download/upload to storage vs accept URL)?
- Do you want an automatic backup (DB copy) before overwriting in Phase 4, or defer backups to Phase 6?

Suggested quick checklist to append to Phase 4 notes
- Add Revise UI only after 4.1.1–4.1.4 are complete.
- Define revision response schema and client validation rules before coding.
- Enforce prompt size guarding (truncate or summarize large source stories).
- Make “Save as New” the safer default; require explicit confirmation for overwrite.
- Ensure idempotencyKey and RLS safety for all save/update operations.

(Keep this feature flagged as post‑Phase‑4 optional until core generation/preview/save flows are stable.)


# note added by developer

I will want to take all the tests and code in this repo and put it in a repomix set to make sure that they're sensible and covering things well

Claude Sonnet 4 had huge problems at around task 2.1.1, 2.1.2, where it couldn't solve an authentication / validation glitch where the sign in fields kept showing 'field required' and disabling the 'sign in' button, even when filled properly.  It took Claude lots of effort and the use of a repomix file set to try to debug this and it still failed to solve it.

It kept saying confidently that it could definitely see the problem, and then it proceeded to apply extensive and various code changes that would have no effect on the problematic UI behaviour.  Claude sonnet 4 was not able to get the true sign in form to work, but it was able to make a 'test authentication' component that was able to sign in.  When asked to make the sign in form work using the same logic as the working test authentication form, it could not achieve this even though it said that they were matching exactly.

I was about to roll back the repo to a prior checkpoint or try deleting all the related files and building them again, but somehow just switching to GPT-5 mini was enough for it to read the repomix and look at the problem, and understand that there was an issue with v-model not connecting the fields to the validator logic properly and the authentication issue was solved.

GPT-5 mini was then far more helpful for being able to troubleshoot further errors with supabase authentication tokens, vite environment variables, and detecting whether github environment secrets were successfully being injected in github action workflows. GPT-5 mini was also able to make the true sign in form work with the same logic as the test authentication component and get the project back on track.

So at this point, the project is switching from having claude Sonnet 4 be the coding agent to having GPT-5 mini be the coding agent for a (currently) much more effective, informative, and time-saving experience.

Claude in agent mode would go ahead and make speculative changes in hopes of them working, and so there are a lot of strange files left over like old .ts files left in place just so that tests that used to expect them can still pass.  Soon, it will be important to look for and clean up such unneeded files and tests.

