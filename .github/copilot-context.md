# Copilot Working Memory Reference

## Current Project State
- **Last Known Good State**: All unit tests passing (154/154). StoryDetails route and view implemented; filters working; date presets in useStories.
- **Currently Working**: Phase 3.2.1b completed. UX improvements on guest hero and header nav.
- **Last Test Results**: 100% pass. Prior unhandled promise rejections in StoryDetails resolved.
- **Known Issues**:
  - Preview modal still deferred (3.1.1e).

## Key File Relationships
- `StoryDetails.vue` uses: `useStory.getById`, `vue-router useRoute` (watches `params.id`).
- `useStory.ts` depends on: `utils/supabase` client; table `story_starter_stories`.
- `Home.vue` uses: `StoryFilters`, `useStories.fetchPublic/fetchMine` with normalized filters.
- `App.vue` header now clickable to home; Demo nav removed.

## Recent Changes Made
- [2025-09-18]: Implemented `useStory.getById` with Supabase select('*').
- [2025-09-18]: Refactored `StoryDetails.vue` to watch route param and harden load() against undefined/throw; fixed flaky tests; eliminated unhandled errors.
- [2025-09-18]: Revamped guest marketing hero in `Home.vue` (centered, gradient, improved copy, CTA).
- [2025-09-18]: Made “Story Starter” header clickable to Home; removed Demo tab and demo fallback section in `App.vue`.

## Next Steps Plan
1. 3.2.2 (Edit/Delete scaffolding): tests-first for permissions and UI affordances.
2. Later: revisit hero copy/styles per user feedback; add responsive tweaks if desired.
3. Prepare Phase 4 tests-first (generation form, prompt builder, edge proxy contract).

## Verification Plan
- Automated: `npx vitest run` should remain green.
- Manual: Navigate as guest to Home → see new hero; click header logo/title → goes Home; no Demo tab visible.

## Rollback Plan
- Revert `StoryDetails.vue` changes if any regressions in detail loading.
- Revert `Home.vue` hero edits if copy/layout not desired.
- Re-add Demo nav if needed; tests will still pass without it.

## Human-parsable summary
- 3.2.1b is functionally complete: route exists, view fetches by id, tests pass, and the view is resilient.
- UX: guest hero is now a centered, colorful gradient panel with clearer messaging and a CTA; header logo/title is a Home button; Demo tab removed.

Update timestamp: 2025-09-18.



## Context Section about Phase 4 Planning (Generated by another model in ask mode — agents, don’t directly edit this section but be aware of it)

Purpose
- Deliver LLM-based story generation via a minimal Supabase Edge Function proxy (“gemini-proxy”) that only sanitizes inputs/outputs and enforces basic limits/rate‑limits. All prompt engineering and output parsing happen on the frontend.
- Phase 4 is the MVP for generation; Phase 6 adds advanced controls (seed lock, custom types, richer undo, metadata persistence).

User journey
- User clicks “Generate New Story.”
- A form collects structured prompts:
  - Story type: short-story | movie-summary | tv-commercial. Internally stored as hyphen‑slugs; UI displays labels with spaces (“Short story,” “Movie summary,” “TV commercial”).
  - Optional title, genre, tone, creativity.
  - Dynamic tags: themes, plot points.
  - Dynamic characters: name, role (protagonist/antagonist/ally/other), optional description.
  - Free‑text “additional instructions” (warn if > 800 chars; allow up to 2000).
  - Optional image (upload to Supabase Storage or paste URL).
  - Privacy toggle (default private; user can opt‑in to public).
- Submit:
  - Frontend constructs the full model prompt string (prompt engineering lives entirely in the client).
  - Frontend instructs Gemini to return strict JSON (via prompt content).
  - Frontend POSTs that final prompt string to the gemini‑proxy Edge Function.
- Edge Function behavior:
  - Validates request size and rate limits.
  - Sanitizes the incoming prompt (trim/collapse whitespace, strip obvious HTML/scripts/control characters).
  - Forwards the sanitized prompt to Gemini as‑is (no server-side templating or schema instructions).
  - Receives Gemini text, sanitizes it (remove BOM, dangerous tags, normalize whitespace; optionally pass through code‑fences untouched).
  - Returns sanitized text to the frontend without parsing or reformatting.
- Frontend then:
  - Cleans fences/backticks if needed, extracts JSON, validates against the client schema, and shows a preview.
  - From preview: Save (persist), Retry (fresh sample) with Undo to restore previous preview, Edit prompts (return to form), or Discard (no persistence).
  - Drafts remain in memory only until Save (no “draft” rows in DB for Phase 4).

Data conventions and limits
- Story types: hyphen slugs in DB/APIs; space‑separated labels in UI.
- Images:
  - Allowed types: png, jpeg, webp.
  - Max size: 2 MB.
  - Dimensions: min 200×200, max 4000×4000; any aspect ratio.
  - Stored in bucket story-covers with owner‑only RLS; display via signed URLs.
  - If none, show type‑specific monochrome SVG fallback (decorative, aria‑hidden):
    - Short story → open book (slate/gray).
    - Movie summary → filmstrip (indigo/blue).
    - TV commercial → clapperboard or megaphone (emerald/green).
- Input validation (client) and guidance:
  - Title ≤ 120; Genre ≤ 60; Tone ≤ 60.
  - Themes ≤ 10, each ≤ 30.
  - Plot points ≤ 10, each ≤ 200.
  - Characters ≤ 6; name ≤ 60; description ≤ 400; role is enum.
  - Additional instructions ≤ 2000; warn when > 800 (latency hint).
- Server safeguards (edge):
  - Enforce reasonable total input budget (~6000 chars) and moderate rate limits.
  - Return sanitized model text; do not attempt JSON parsing.

Privacy and access control
- Default is_private = true on the form; Save preserves user choice.
- RLS: anon can read public; authenticated can read public + own; writes are owner‑only with WITH CHECK.

Retry/Undo semantics
- Retry always requests a fresh sample (no deterministic seed in Phase 4).
- When a retry completes, the preview is replaced; Undo restores the prior preview (single‑level undo).
- Phase 6 will add a visible “Lock seed” toggle for deterministic generations, and deeper undo for text fields.

Responsibilities split
- Frontend:
  - Prompt builder: composes final model prompt, includes strict “respond only with JSON” instructions and the JSON schema description.
  - Calls gemini‑proxy with the prompt string.
  - Extracts and parses JSON from the sanitized text; validates schema; handles user‑visible errors.
  - Image validation/upload, preview, save flow, idempotency on Save, toasts.
- Edge function:
  - Safety and hygiene only: input/output sanitization, size caps, moderate per‑user rate limits (e.g., default: ~8/min, 60/hour, 200/day — adjustable via env).
  - Transparent pass‑through to Gemini; no server‑side templating or response shaping beyond sanitization.
  - Clear error taxonomy: 400 validation, 429 rate limit with Retry‑After, 5xx transient.

Out of scope for Phase 4 (defer to Phase 6+)
- Custom story types authored by users.
- Persisting generation request metadata (prompts/settings) in DB.
- Deterministic seed controls (add visible “Lock seed” toggle later).
- Multi‑level undo for form editors.
- AI image generation.

Quality gates for Phase 4
- TDD for form behavior, prompt builder, client parsing, preview/save/undo, image pipeline, and edge function contract (sanitization + rate limit).
- Manual checklist includes privacy default, length caps/warnings, upload constraints, retry→undo, 429 handling UX, and basic a11y.

Key risks and mitigations
- Non‑JSON model replies → robust client extraction and schema validation; friendly parse errors.
- Latency → input caps and 800‑char warning; visible progress; no server templating to keep flow simple.
- Duplicate saves → client idempotency key; disable Save while pending.
- Storage misuse → client/type/size/dimension checks + bucket RLS; signed URLs only.

Here’s the append-only update block for the Phase 4 section.

## Phase 4 Addendum — New Decisions and Execution Details (since last update)

- Model default: gemini-2.5-flash.
- Edge function request shape confirmed: POST { prompt: string } only; proxy sanitizes input/output and forwards as-is; frontend owns prompt engineering and JSON parsing.
- Rate-limit/env knobs finalized: RL_BURST, RL_PER_HOUR, RL_PER_DAY, MAX_PROMPT_CHARS (~6000). Moderate defaults; adjustable via env.
- Storage confirmed: bucket story-covers; path userId/storyId/filename; owner-only RLS; signed-URL viewing.
- Test strategy (TDD) options:
  - Option A (parallel-safe): place Phase 4 specs under tests/phase4 and gate them so CI/Phase 3 aren’t affected. Local run:
    ````bash
    RUN_PHASE4=1 vitest --include "tests/phase4/**/*.spec.ts" --watch
    ````
    Gate each spec:
    ````ts
    const RUN_PHASE4 = process.env.RUN_PHASE4 === '1';
    (RUN_PHASE4 ? describe : describe.skip)('Phase 4 — <suite>', () => { /* … */ });
    ````
  - Option B (single-stream): when Phase 3 wraps or if the same agent continues, place tests in the normal locations immediately (tests/unit, tests/integration, tests/edge) without gating.
- Branching to avoid collisions with Phase 3: work on a phase4-prep branch; separate VS Code window optional. Do not touch:
  - src/components/stories/*, src/views/Home.vue, src/composables/useStories.ts, or existing Phase 3 tests.
- Safe, additive deliverables to start now (unreferenced by Phase 3):
  - docs/phase4/: gemini-proxy contract + runbook, image pipeline guide, prompt-builder notes, a11y/UX checklist.
  - supabase/functions/gemini-proxy/: sanitize-and-forward scaffold with env-driven limits (not wired to UI).
  - src/utils/: extractJson, slugify/humanize story type, imageValidation, idempotencyKey (+ gated tests).
  - src/types/generation.ts; src/composables/useGeneration.ts (stub; not imported yet).
- Execution note: test gating is optional. If the current Phase 3 agent proceeds to Phase 4 next, use Option B and place tests in the standard folders.


## Phase 4 Addendum — Optional “Revise with AI” for Existing Stories (post‑Phase‑4)

Summary
- Feature: add a “Revise with AI” action available on any story the current user owns.
- Flow:
  1. Owner clicks “Revise with AI”.
  2. Modal shows the existing story text (read‑only) and a free‑text instructions box where the user writes revision goals (≤ 2000 chars; warn if > 800).
  3. Frontend composes the prompt (story text + user instructions) and POSTs { prompt: string } to gemini‑proxy.
  4. gemini‑proxy sanitizes and forwards; frontend receives sanitized text, extracts JSON or content, validates it, and shows a preview of the revised text.
  5. User chooses: Save as New Story OR Overwrite Existing Story. If overwrite, show confirmation (irreversible) and require an explicit confirm.
  6. Save uses owner RLS; idempotency key prevents double writes. If overwriting, preserve user_id and ensure update policy WITH CHECK prevents ownership changes.
- Implementation timing: deferred until Phase 4 core generation/save/preview/image flows are complete.

Important implementation/UX considerations
- Prompt limits & token budget: raw story text can be large. Enforce client truncation or summarize long stories before sending; warn user about cost/latency when large.
- Response shape: decide expected response (full JSON with title/description/content/image_url or plain revised content). Document schema the frontend will validate.
- Overwrite safety: require explicit confirmation and surface a clear rollback plan (encourage “Save as New” by default). Consider auto‑creating a backup copy before overwrite (Phase 6 enhancement).
- Permissions: only story owners may use this; enforce via UI and server RLS.
- Rate limits & quotas: revisions count against generation quota; ensure gemini‑proxy rate limits and UX reflect 429/retry guidance.
- Idempotency & dedupe: include idempotencyKey to avoid duplicate saves when users retry.
- Metadata & audit: kept out of Phase 4 per earlier decision. If you want traceability later, plan to add generation metadata storage in Phase 6.
- Images: if the revised output may include image_url, decide whether to accept and persist it; validate URL or offer upload instead.
- Undo/history: Phase 4 offers single confirmation. Phase 6 can add multi‑version history and multi‑level undo.
- Edge function budget: consider a slightly higher MAX_PROMPT_CHARS for revision flows or add a summarization step to reduce prompt size.

Questions to clarify (for inclusion in the plan)
- Default save behavior: prefer “Save as New” by default, or present both options equally?
- Expected response schema for revisions (full JSON with metadata, or just content string)?
- Will we allow the revision to change story_type/genre/title, or only content?
- Should overwrites automatically update the existing story_count/profile triggers, or should we treat overwrites as distinct for analytics?
- Any special rules for images in revised responses (auto‑download/upload to storage vs accept URL)?
- Do you want an automatic backup (DB copy) before overwriting in Phase 4, or defer backups to Phase 6?

Suggested quick checklist to append to Phase 4 notes
- Add Revise UI only after 4.1.1–4.1.4 are complete.
- Define revision response schema and client validation rules before coding.
- Enforce prompt size guarding (truncate or summarize large source stories).
- Make “Save as New” the safer default; require explicit confirmation for overwrite.
- Ensure idempotencyKey and RLS safety for all save/update operations.

(Keep this feature flagged as post‑Phase‑4 optional until core generation/preview/save flows are stable.)


#### Copilot Working Memory Reference

###### Current Project State
- Last Known Good State: prompt-plan-claude-sonnet-4 branch after 3.2.1c edit mode scaffolding; all tests were reported passing before adding delete tests
- Currently Working: 3.2.1e — add failing tests for Delete with confirmation on StoryDetails
- Last Test Results: Prior run passed; new spec StoryDetails.delete.spec.ts expected to fail initially
- Known Issues: Edit persistence (useStory.update) not yet wired; Delete flow not implemented

###### Key File Relationships
- `src/views/StoryDetails.vue` depends on: `useStory` (getById, update/remove), `useAuth`, `vue-router`
- `tests/unit/StoryDetails.delete.spec.ts` uses: router navigation to /stories/:id, mocks `useStory` and `useAuth`
- Authentication flow: `useAuth().user.value?.id` compared to `story.user_id` to determine ownership

###### Recent Changes Made
- 2025-09-18: Added `tests/unit/StoryDetails.delete.spec.ts` to define Delete UI/behavior contract (owner-only, confirm dialog, calls remove, navigates home)
- 2025-09-18: Updated working memory for next steps

###### Next Steps Plan
1. Run tests to observe new failures from StoryDetails.delete.spec.ts
2. Implement 3.2.1f: Delete UI — owner-only Delete button, confirm dialog with data-testids, call useStory.remove(id), navigate to Home on success; add toasts
3. Verify by running tests again; also manual check via router to /stories/:id

###### Complexity Warning Signs
- [ ] More than 5 files need changes
- [ ] Circular dependencies detected
- [ ] Test failure cascade
- [ ] Can't predict impact of changes

###### assumptions about the project that changed when new things were learned
- Initial assumption: StoryDetails lacked edit/delete; Now: Edit mode exists; Delete pending
- New information: Router fallback in App.vue handles '/demo' for tests

###### Human parseable summary of state and insights derived from reading most recent repomix files
- StoryDetails already has owner check and edit scaffolding; adding delete should follow same ownership pattern and use consistent data-testids: delete-btn, delete-confirm, confirm-delete-confirm.

